const mongoose = require('mongoose');\n\n/**\n * Modèle Mongoose pour les campagnes d'attaque\n */\nconst CampaignSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true,\n    unique: true,\n    trim: true\n  },\n  description: {\n    type: String\n  },\n  startDate: {\n    type: Date,\n    required: true\n  },\n  endDate: {\n    type: Date\n  },\n  status: {\n    type: String,\n    enum: ['Active', 'Historical', 'Emerging'],\n    default: 'Active'\n  },\n  attackGroups: [{\n    type: String,\n    trim: true\n  }],\n  techniques: [{\n    type: String,\n    trim: true\n  }],\n  malware: [{\n    type: String,\n    trim: true\n  }],\n  targetSectors: [{\n    type: String,\n    trim: true\n  }],\n  targetCountries: [{\n    type: String,\n    trim: true\n  }],\n  impactLevel: {\n    type: String,\n    enum: ['Low', 'Medium', 'High', 'Critical'],\n    default: 'Medium'\n  },\n  indicators: [{\n    type: {\n      type: String,\n      enum: ['IP', 'Domain', 'Hash', 'URL'],\n      required: true\n    },\n    value: {\n      type: String,\n      required: true\n    },\n    firstSeen: {\n      type: Date\n    },\n    lastSeen: {\n      type: Date\n    }\n  }],\n  references: [{\n    url: {\n      type: String,\n      required: true\n    },\n    source: {\n      type: String,\n      required: true\n    },\n    description: {\n      type: String\n    }\n  }],\n  createdAt: {\n    type: Date,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    default: Date.now\n  }\n}, {\n  timestamps: true\n});\n\n// Index pour les recherches textuelles\nCampaignSchema.index({ \n  name: 'text', \n  description: 'text' \n});\n\n// Index pour les recherches par date\nCampaignSchema.index({ startDate: 1 });\nCampaignSchema.index({ endDate: 1 });\nCampaignSchema.index({ status: 1 });\n\n// Middleware pour mettre à jour la date de dernière modification\nCampaignSchema.pre('save', function(next) {\n  this.updatedAt = Date.now();\n  \n  // Mise à jour automatique du statut en fonction des dates\n  const now = new Date();\n  \n  if (this.endDate && this.endDate < now) {\n    this.status = 'Historical';\n  } else if (this.startDate > now) {\n    this.status = 'Emerging';\n  } else {\n    this.status = 'Active';\n  }\n  \n  next();\n});\n\n// Méthode pour obtenir les détails complets des groupes d'attaque\nCampaignSchema.methods.getAttackGroups = async function() {\n  const AttackGroup = mongoose.model('AttackGroup');\n  return await AttackGroup.find({ name: { $in: this.attackGroups } });\n};\n\n// Méthode pour obtenir les détails complets des techniques\nCampaignSchema.methods.getTechniques = async function() {\n  const Technique = mongoose.model('Technique');\n  return await Technique.find({ mitreId: { $in: this.techniques } });\n};\n\n// Méthode pour obtenir les détails complets des malwares\nCampaignSchema.methods.getMalware = async function() {\n  const Malware = mongoose.model('Malware');\n  return await Malware.find({ name: { $in: this.malware } });\n};\n\n// Méthode statique pour trouver les campagnes actives\nCampaignSchema.statics.findActive = function() {\n  return this.find({ status: 'Active' }).sort('-startDate');\n};\n\n// Méthode statique pour trouver les campagnes récentes (dans les X derniers jours)\nCampaignSchema.statics.findRecent = function(days = 90) {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - days);\n  \n  return this.find({\n    $or: [\n      { startDate: { $gte: cutoffDate } },\n      { endDate: { $gte: cutoffDate } },\n      { status: 'Active' }\n    ]\n  }).sort('-startDate');\n};\n\nconst Campaign = mongoose.model('Campaign', CampaignSchema);\n\nmodule.exports = Campaign;